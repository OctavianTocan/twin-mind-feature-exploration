<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dictionary</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Set base font and new text color */
      body {
        font-family: "Inter", sans-serif;
        color: #646464; /* User-requested text color */
      }
      /* Ensure html and body take full height for a mobile-like view */
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      /* Custom styles for the dark blue color */
      .btn-primary {
        background-color: #0b4f75;
        color: white;
        padding: 0.5rem 1.5rem; /* py-2 px-6 */
        font-size: 0.875rem; /* text-sm */
        border-radius: 0.5rem; /* rounded-lg */
        transition-property: background-color;
        transition-duration: 150ms;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        line-height: 1.25rem; /* leading-5 */
      }
      .btn-primary:hover:not(:disabled) {
        background-color: #0a4268;
      }
      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Custom styles for the toggle switch - Increased size for better touch target */
      .toggle-switch-container {
        padding: 0.5rem; /* Add padding around the toggle for easier tap */
        border-radius: 0.5rem;
        margin: -0.5rem; /* Negative margin to counteract the padding for spacing */
      }
      /* REMOVED hover rule for toggle-switch-container */

      .toggle-track {
        height: 1.5rem; /* Increased height */
        width: 2.75rem; /* Increased width */
      }
      .toggle-ball {
        height: 1.25rem; /* Increased height */
        width: 1.25rem; /* Increased width */
      }
      .toggle-checkbox:checked + .toggle-label .toggle-ball {
        transform: translateX(
          1.25rem
        ); /* Adjusted transform to match new track size */
      }

      .toggle-checkbox:checked {
        background-color: #0b4f75; /* Custom Blue */
        right: 0;
      }
      .toggle-checkbox:checked + .toggle-label {
        background-color: #0b4f75; /* Custom Blue */
      }
      .toggle-checkbox:checked + .toggle-label .toggle-ball {
        transform: translateX(
          1.5rem
        ); /* Adjusted transform to match new track size */
      }

      /* Custom styles for the header button text color (from the light mode images) */
      .text-blue-primary {
        color: #0b4f75;
      }

      /* Added for new title font */
      .font-helvetica {
        font-family: "Helvetica Neue", Arial, sans-serif;
      }

      /* Elevated/glassy surface style for prominent buttons */
      .btn-elevated {
        border-radius: 0.75rem; /* rounded-xl */
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.85),
          0 1px 2px rgba(16, 24, 40, 0.06), 0 8px 24px rgba(16, 24, 40, 0.12);
        backdrop-filter: saturate(120%);
      }
      .btn-elevated:hover {
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.9),
          0 4px 8px rgba(16, 24, 40, 0.12), 0 14px 34px rgba(16, 24, 40, 0.16);
      }
      .btn-elevated:active {
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.75),
          0 1px 2px rgba(16, 24, 40, 0.08), 0 8px 22px rgba(16, 24, 40, 0.18);
      }
      .btn-elevated-strong {
        border-radius: 0.9rem;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.9),
          0 6px 14px rgba(16, 24, 40, 0.16), 0 20px 44px rgba(16, 24, 40, 0.2);
      }
      .btn-elevated:focus-visible {
        outline: 2px solid rgba(0, 0, 0, 0.85);
        outline-offset: 1px;
      }

      /* Strong shadow for the whole panel over dimmed background */
      .panel-elevated {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.28),
          0 2px 10px rgba(0, 0, 0, 0.15);
      }

      /* Copilot-like surface for buttons: translucent white bg with subtle border */
      .btn-surface {
        background-color: rgba(255, 255, 255, 0.3) !important;
        border: 0.8px solid rgba(0, 0, 0, 0.08);
        border-radius: 12px;
        backdrop-filter: blur(10px);
      }
      .btn-surface:hover {
        background-color: rgba(255, 255, 255, 0.4) !important;
        border-color: rgba(0, 0, 0, 0.12);
      }

      /* Larger button helper for the primary CTA */
      .btn-lg {
        padding-top: 0.875rem; /* ~py-3.5 */
        padding-bottom: 0.875rem;
        font-size: 1rem; /* text-base */
        line-height: 1.5rem; /* leading-6 */
        /* no bold weight for larger CTA */
      }
    </style>
  </head>
  <body class="bg-gray-100 flex justify-center items-start min-h-screen py-8">
    <!-- Background TwinMind iframe (non-interactive) -->
    <iframe
      src="https://app.twinmind.com/m/d753c9b5-c8a7-41a3-aab5-dc3be9d39a2e"
      title="TwinMind App Preview"
      loading="lazy"
      referrerpolicy="no-referrer-when-downgrade"
      style="
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        border: 0;
        z-index: 0;
        pointer-events: none;
      "
    ></iframe>
    <!-- Dark overlay between background and panel -->
    <div
      style="
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        z-index: 5;
        pointer-events: none;
      "
    ></div>
    <!-- Main container with mobile-like constraints, wider on desktop -->
    <div
      class="w-full max-w-md md:max-w-lg bg-white p-5 flex flex-col rounded-lg shadow-lg panel-elevated relative z-10"
    >
      <!-- Top navigation: Back, Title, and Save buttons -->
      <header class="flex justify-between items-center mb-6 w-full">
        <button
          class="text-blue-primary text-base rounded-full px-2 py-1 flex items-center gap-1 hover:bg-gray-100"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
              clip-rule="evenodd"
            />
          </svg>
          Back
        </button>
        <h1
          class="text-[1.75rem] font-bold text-[#4F4F4F] leading-[1.3] tracking-[0.096px] font-helvetica"
        >
          Dictionary
        </h1>
        <button
          class="text-blue-primary text-base rounded-full px-3 py-1 font-medium hover:bg-gray-100"
        >
          Save
        </button>
      </header>

      <!-- Main content area -->
      <main class="flex-grow w-full">
        <!-- Explanatory Text (inherits new body color) -->
        <p class="text-sm mb-6">
          Add words and corrections to your dictionary. This helps improve
          transcription accuracy for unique names and terms.
        </p>

        <!-- "Add new" Button for Desktop -->
        <div class="mb-6 hidden md:block">
          <button
            id="openAddModalButton"
            class="btn-lg w-full font-normal"
            style="background-color: #0b4f75; color: white; border: 0.8px solid rgba(255, 255, 255, 0.2); border-radius: 12px; padding: 0.875rem 1.5rem; font-size: 1rem; line-height: 1.5rem; backdrop-filter: blur(10px);"
          >
            Add new
          </button>
        </div>

        <!-- Inline "Add new word" Form (Mobile-only) -->
        <div id="inlineAddFormContainer" class="mb-6 block md:hidden">
          <h2 class="text-lg font-bold mb-3">Add new word</h2>

          <!-- Toggle for 'Correct a misspelling' -->
          <div class="flex items-center justify-between mb-5">
            <!-- Label inherits new body color -->
            <label for="addFormMisspellingToggle" class="font-medium text-sm"
              >Correct a misspelling</label
            >
            <!-- Increased touch target area -->
            <button
              class="relative inline-flex items-center toggle-switch-container"
              role="switch"
              aria-checked="false"
              id="addFormToggleButton"
            >
              <input
                type="checkbox"
                id="addFormMisspellingToggle"
                class="sr-only toggle-checkbox"
              />
              <span class="sr-only">Correct a misspelling</span>
              <span
                class="inline-block toggle-track rounded-full transition-colors bg-gray-300 relative"
              >
                <span
                  class="inline-block toggle-ball transform bg-white rounded-full shadow transition-transform absolute left-[2px] top-[2px]"
                ></span>
              </span>
            </button>
          </div>

          <!-- Input fields for Add Form -->
          <div class="space-y-3">
            <!-- Single word input -->
            <div id="addFormSingleWordContainer">
              <label for="addFormSingleWordInput" class="sr-only"
                >Add a new word</label
              >
              <input
                type="text"
                id="addFormSingleWordInput"
                placeholder="Add a new word"
                class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
              />
            </div>

            <!-- Replacement inputs (hidden by default) -->
            <div
              id="addFormReplacementContainer"
              class="hidden flex items-center gap-3"
            >
              <input
                type="text"
                id="addFormWordToReplaceInput"
                placeholder="Misspelling"
                class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
              />
              <span class="text-[#0B4F75] text-xl">&rarr;</span>
              <input
                type="text"
                id="addFormReplaceWithInput"
                placeholder="Correct spelling"
                class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
              />
            </div>
          </div>

          <!-- Add Button for Inline Form - Using custom class for styling -->
          <button id="addFormSaveButton" class="w-full mt-5" style="background-color: #0b4f75; color: white; border: 0.8px solid rgba(255, 255, 255, 0.2); border-radius: 12px; padding: 0.5rem 1.5rem; font-size: 0.875rem; line-height: 1.25rem; backdrop-filter: blur(10px);">
            Add word
          </button>
        </div>

        <!-- Divider -->
        <hr class="border-t-2 border-gray-200 my-6" />

        <!-- Dictionary List Container -->
        <div id="dictionaryListContainer" class="flex flex-col w-full">
          <!-- Dictionary items will be dynamically added here -->
        </div>
      </main>
    </div>

    <!-- Modal Overlay -->
    <div
      id="modalOverlay"
      class="fixed inset-0 bg-black bg-opacity-50 hidden z-40"
    ></div>

    <!-- Entry Modal (for Add/Edit) -->
    <div
      id="entryModal"
      class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white w-full max-w-md p-5 rounded-lg shadow-2xl hidden z-50"
    >
      <h2 id="entryModalTitle" class="text-xl font-bold mb-4">Edit word</h2>

      <!-- Toggle for 'Correct a misspelling' -->
      <div class="flex items-center justify-between mb-4">
        <label for="entryModalMisspellingToggle" class="font-medium text-sm"
          >Correct a misspelling</label
        >
        <!-- Increased touch target area -->
        <button
          class="relative inline-flex items-center toggle-switch-container"
          role="switch"
          aria-checked="false"
          id="entryModalToggleButton"
        >
          <input
            type="checkbox"
            id="entryModalMisspellingToggle"
            class="sr-only toggle-checkbox"
          />
          <span class="sr-only">Correct a misspelling</span>
          <span
            class="inline-block toggle-track rounded-full transition-colors bg-gray-300 relative"
          >
            <span
              class="inline-block toggle-ball transform bg-white rounded-full shadow transition-transform absolute left-[2px] top-[2px]"
            ></span>
          </span>
        </button>
      </div>

      <!-- Input fields (tighter spacing) -->
      <div class="space-y-2">
        <!-- Single word input -->
        <div id="entryModalSingleWordInputContainer">
          <label for="entryModalSingleWordInput" class="sr-only"
            >Add a new word</label
          >
          <input
            type="text"
            id="entryModalSingleWordInput"
            placeholder="Add a new word"
            class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
          />
        </div>

        <!-- Replacement inputs (hidden by default) -->
        <div
          id="entryModalReplacementInputContainer"
          class="hidden flex items-center gap-3"
        >
          <input
            type="text"
            id="entryModalWordToReplaceInput"
            placeholder="Misspelling"
            class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
          />
          <span class="text-[#0B4F75] text-xl">&rarr;</span>
          <input
            type="text"
            id="entryModalReplaceWithInput"
            placeholder="Correct spelling"
            class="w-full bg-gray-50 border border-gray-300 text-sm rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-[#0B4F75]"
          />
        </div>
      </div>

      <!-- Modal buttons (tighter spacing) -->
      <div class="flex justify-end items-center gap-3 mt-5">
        <button
          id="entryModalDeleteButton"
          class="btn-surface font-medium text-sm px-5 py-2.5 hidden mr-auto"
          style="color: rgb(220, 38, 38);"
        >
          Delete
        </button>
        <button
          id="entryModalCancelButton"
          class="btn-surface font-medium text-sm px-5 py-2.5"
          style="color: rgb(99, 92, 87);"
        >
          Cancel
        </button>
        <!-- Save Button - Using custom class for styling -->
        <button id="entryModalSaveButton" style="background-color: #0b4f75; color: white; border: 0.8px solid rgba(255, 255, 255, 0.2); border-radius: 12px; padding: 0.5rem 1.5rem; font-size: 0.875rem; line-height: 1.25rem; backdrop-filter: blur(10px);">
          Save changes
        </button>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- STATE ---
        let dictionaryItems = [
          {
            id: crypto.randomUUID(),
            type: "replacement",
            from: "open memory",
            to: "OpenMemory",
          },
          {
            id: crypto.randomUUID(),
            type: "word",
            word: "tocanoctavian@gmail.com",
          },
          { id: crypto.randomUUID(), type: "word", word: "Octavian Tocan" },
          { id: crypto.randomUUID(), type: "word", word: "Pieces for Desktop" },
          { id: crypto.randomUUID(), type: "word", word: "Ollama" },
          { id: crypto.randomUUID(), type: "word", word: "Figma Jam" },
          { id: crypto.randomUUID(), type: "word", word: "procedural" },
          {
            id: crypto.randomUUID(),
            type: "replacement",
            from: "mem0",
            to: "Mem0",
          },
          {
            id: crypto.randomUUID(),
            type: "replacement",
            from: "memzero",
            to: "Mem0",
          },
        ];
        let editingItemId = null;

        // --- SELECTORS ---
        const listContainer = document.getElementById(
          "dictionaryListContainer"
        );
        const modalOverlay = document.getElementById("modalOverlay");

        // Entry Modal Selectors
        const entryModal = document.getElementById("entryModal");
        const entryModalTitle = document.getElementById("entryModalTitle");
        const entryModalToggleButton = document.getElementById(
          "entryModalToggleButton"
        );
        const entryModalMisspellingToggle = document.getElementById(
          "entryModalMisspellingToggle"
        );
        const entryModalSingleWordInputContainer = document.getElementById(
          "entryModalSingleWordInputContainer"
        );
        const entryModalReplacementInputContainer = document.getElementById(
          "entryModalReplacementInputContainer"
        );
        const entryModalSingleWordInput = document.getElementById(
          "entryModalSingleWordInput"
        );
        const entryModalWordToReplaceInput = document.getElementById(
          "entryModalWordToReplaceInput"
        );
        const entryModalReplaceWithInput = document.getElementById(
          "entryModalReplaceWithInput"
        );
        const entryModalDeleteButton = document.getElementById(
          "entryModalDeleteButton"
        );
        const entryModalCancelButton = document.getElementById(
          "entryModalCancelButton"
        );
        const entryModalSaveButton = document.getElementById(
          "entryModalSaveButton"
        );

        // Add Form Selectors (Inline Mobile Form)
        const addFormToggleButton = document.getElementById(
          "addFormToggleButton"
        );
        const addFormMisspellingToggle = document.getElementById(
          "addFormMisspellingToggle"
        );
        const addFormSingleWordContainer = document.getElementById(
          "addFormSingleWordContainer"
        );
        const addFormReplacementContainer = document.getElementById(
          "addFormReplacementContainer"
        );
        const addFormSingleWordInput = document.getElementById(
          "addFormSingleWordInput"
        );
        const addFormWordToReplaceInput = document.getElementById(
          "addFormWordToReplaceInput"
        );
        const addFormReplaceWithInput = document.getElementById(
          "addFormReplaceWithInput"
        );
        const addFormSaveButton = document.getElementById("addFormSaveButton");

        // Desktop "Add new" Button
        const openAddModalButton =
          document.getElementById("openAddModalButton");

        // --- FUNCTIONS ---

        // Render the entire list of dictionary items
        const renderList = () => {
          listContainer.innerHTML = ""; // Clear existing list

          if (dictionaryItems.length === 0) {
            listContainer.innerHTML = `<p class="text-gray-500 text-center py-3 text-sm">Your dictionary is empty.</p>`;
          }

          dictionaryItems.forEach((item) => {
            // Create the main item element as a div
            const itemEl = document.createElement("div");
            itemEl.className =
              "w-full flex justify-between items-center px-3 py-3 border-b border-gray-200 text-sm";
            itemEl.dataset.id = item.id;

            // Create content element
            const contentEl = document.createElement("div");
            if (item.type === "word") {
              contentEl.textContent = item.word;
            } else {
              contentEl.innerHTML = `
                            <span class="opacity-70">${item.from}</span>
                            <span class="mx-2 text-[#0B4F75]">&rarr;</span>
                            <span class="font-semibold">${item.to}</span>
                        `;
            }

            // Create actions container
            const actionsEl = document.createElement("div");
            actionsEl.className = "flex items-center gap-2";

            // Create Edit Button
            const editBtn = document.createElement("button");
            editBtn.className =
              "p-2 rounded-full text-gray-400 hover:bg-gray-100 hover:text-[#0B4F75] transition-colors";
            editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>`;
            editBtn.title = "Edit item";
            editBtn.addEventListener("click", () => openEditModal(item.id));

            // Create Delete Button
            const deleteBtn = document.createElement("button");
            deleteBtn.className =
              "p-2 rounded-full text-gray-400 hover:bg-gray-100 hover:text-red-600 transition-colors";
            deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>`;
            deleteBtn.title = "Delete item";
            deleteBtn.addEventListener("click", (e) => {
              e.stopPropagation(); // Prevent any other clicks
              handleListDelete(item.id);
            });

            // Append buttons to actions
            actionsEl.appendChild(editBtn);
            actionsEl.appendChild(deleteBtn);

            // Append content and actions to item element
            itemEl.appendChild(contentEl);
            itemEl.appendChild(actionsEl);

            listContainer.appendChild(itemEl);
          });
        };

        // Renamed from handleDirectDelete
        const handleListDelete = (id) => {
          // In a real app, you'd show a confirmation modal here
          // For this example, we'll delete directly
          dictionaryItems = dictionaryItems.filter((item) => item.id !== id);
          renderList();
        };

        // Toggle the inputs in the modal OR the add form
        const updateFormInputs = (isReplacement, context) => {
          const elements = {
            singleContainer:
              context === "inline"
                ? addFormSingleWordContainer
                : entryModalSingleWordInputContainer,
            replacementContainer:
              context === "inline"
                ? addFormReplacementContainer
                : entryModalReplacementInputContainer,
            toggle:
              context === "inline"
                ? addFormMisspellingToggle
                : entryModalMisspellingToggle,
            toggleButton:
              context === "inline"
                ? addFormToggleButton
                : entryModalToggleButton,
          };

          // Manually update the state and styling of the toggle button/track
          const updateToggleVisuals = (isChecked, buttonEl) => {
            const trackEl = buttonEl.querySelector(".toggle-track");
            const ballEl = buttonEl.querySelector(".toggle-ball");

            if (isChecked) {
              trackEl.classList.remove("bg-gray-300", "hover:bg-gray-400");
              trackEl.classList.add("bg-[#0B4F75]");
              ballEl.style.transform = "translateX(1.25rem)";
              buttonEl.setAttribute("aria-checked", "true");
              elements.toggle.checked = true;
            } else {
              trackEl.classList.remove("bg-[#0B4F75]");
              trackEl.classList.add("bg-gray-300");
              ballEl.style.transform = "translateX(0)";
              buttonEl.setAttribute("aria-checked", "false");
              elements.toggle.checked = false;
            }
          };

          // Apply visual update
          updateToggleVisuals(isReplacement, elements.toggleButton);

          if (isReplacement) {
            elements.singleContainer.classList.add("hidden");
            elements.replacementContainer.classList.remove("hidden");
          } else {
            elements.singleContainer.classList.remove("hidden");
            elements.replacementContainer.classList.add("hidden");
          }
        };

        const closeModal = () => {
          modalOverlay.classList.add("hidden");
          entryModal.classList.add("hidden");
          editingItemId = null; // Clear editing state
        };

        const openEditModal = (id) => {
          const item = dictionaryItems.find((i) => i.id === id);
          if (!item) return;

          editingItemId = id;
          entryModalTitle.textContent = "Edit word";
          entryModalSaveButton.textContent = "Save changes";
          entryModalDeleteButton.classList.remove("hidden");

          if (item.type === "word") {
            updateFormInputs(false, "modal");
            entryModalSingleWordInput.value = item.word;
            entryModalWordToReplaceInput.value = "";
            entryModalReplaceWithInput.value = "";
          } else {
            updateFormInputs(true, "modal");
            entryModalWordToReplaceInput.value = item.from;
            entryModalReplaceWithInput.value = item.to;
            entryModalSingleWordInput.value = "";
          }

          modalOverlay.classList.remove("hidden");
          entryModal.classList.remove("hidden");
        };

        const openAddModal = () => {
          editingItemId = null;
          entryModalTitle.textContent = "Add new word";
          entryModalSaveButton.textContent = "Add word";
          entryModalDeleteButton.classList.add("hidden");

          // Reset inputs
          entryModalSingleWordInput.value = "";
          entryModalWordToReplaceInput.value = "";
          entryModalReplaceWithInput.value = "";

          updateFormInputs(false, "modal"); // Reset toggle

          modalOverlay.classList.remove("hidden");
          entryModal.classList.remove("hidden");
        };

        const handleModalSave = () => {
          const isReplacement = entryModalMisspellingToggle.checked;

          if (editingItemId) {
            // --- EDIT LOGIC ---
            let updatedItem;
            if (isReplacement) {
              const from = entryModalWordToReplaceInput.value.trim();
              const to = entryModalReplaceWithInput.value.trim();
              if (!from || !to) return;
              updatedItem = {
                id: editingItemId,
                type: "replacement",
                from,
                to,
              };
            } else {
              const word = entryModalSingleWordInput.value.trim();
              if (!word) return;
              updatedItem = { id: editingItemId, type: "word", word };
            }
            dictionaryItems = dictionaryItems.map((item) =>
              item.id === editingItemId ? updatedItem : item
            );
          } else {
            // --- ADD LOGIC (from modal) ---
            let newItem;
            if (isReplacement) {
              const from = entryModalWordToReplaceInput.value.trim();
              const to = entryModalReplaceWithInput.value.trim();
              if (!from || !to) return;
              newItem = {
                id: crypto.randomUUID(),
                type: "replacement",
                from,
                to,
              };
            } else {
              const word = entryModalSingleWordInput.value.trim();
              if (!word) return;
              newItem = { id: crypto.randomUUID(), type: "word", word };
            }
            dictionaryItems.unshift(newItem);
          }

          renderList();
          closeModal();
        };

        const handleAddItem = () => {
          // (from inline form)
          const isReplacement = addFormMisspellingToggle.checked;
          let newItem;

          if (isReplacement) {
            const from = addFormWordToReplaceInput.value.trim();
            const to = addFormReplaceWithInput.value.trim();
            if (!from || !to) return; // Basic validation
            newItem = {
              id: crypto.randomUUID(),
              type: "replacement",
              from,
              to,
            };

            // Clear inputs
            addFormWordToReplaceInput.value = "";
            addFormReplaceWithInput.value = "";
          } else {
            const word = addFormSingleWordInput.value.trim();
            if (!word) return; // Basic validation
            newItem = { id: crypto.randomUUID(), type: "word", word };

            // Clear input
            addFormSingleWordInput.value = "";
          }

          // --- CHANGED ---
          // Add new item to the beginning of the array
          dictionaryItems.unshift(newItem);
          renderList();
        };

        const handleDeleteInModal = () => {
          if (!editingItemId) return;
          dictionaryItems = dictionaryItems.filter(
            (item) => item.id !== editingItemId
          );
          renderList();
          closeModal();
        };

        // --- EVENT LISTENERS ---
        entryModalCancelButton.addEventListener("click", closeModal);
        modalOverlay.addEventListener("click", closeModal);

        // Entry Modal Listeners
        entryModalToggleButton.addEventListener("click", () => {
          const isChecked = !entryModalMisspellingToggle.checked;
          updateFormInputs(isChecked, "modal");
        });
        entryModalToggleButton.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            const isChecked = !entryModalMisspellingToggle.checked;
            updateFormInputs(isChecked, "modal");
          }
        });
        entryModalSaveButton.addEventListener("click", handleModalSave);
        entryModalDeleteButton.addEventListener("click", handleDeleteInModal);
        entryModalMisspellingToggle.addEventListener("change", (e) => {
          updateFormInputs(e.target.checked, "modal");
        });

        // Inline Add Form Listeners
        addFormToggleButton.addEventListener("click", () => {
          const isChecked = !addFormMisspellingToggle.checked;
          updateFormInputs(isChecked, "inline");
        });
        addFormToggleButton.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            const isChecked = !addFormMisspellingToggle.checked;
            updateFormInputs(isChecked, "inline");
          }
        });
        addFormSaveButton.addEventListener("click", handleAddItem);
        addFormMisspellingToggle.addEventListener("change", (e) => {
          updateFormInputs(e.target.checked, "inline");
        });

        // Desktop "Add new" Button Listener
        openAddModalButton.addEventListener("click", openAddModal);

        // --- INITIAL RENDER ---
        renderList();

        // Set initial state for add form toggle
        updateFormInputs(false, "inline");
      });
    </script>
  </body>
</html>
